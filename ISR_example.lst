0000              1   ; DANIEL NG 38327466 
0000              2   ; ELEC 291 LAB 2 ALARM CLOCK JANUARY 20 2026
0000              3   
0000              4   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              5   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.7 using
0000              6   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              7   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              8   ; zero if the 'CLEAR' push button connected to P1.5 is pressed.
                 10   $LIST
0000             12   
0000             13   ;  N76E003 pinout:
0000             14   ;                               -------
0000             15   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             16   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             17   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             18   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             19   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             20   ;               INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             21   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             22   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             23   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             24   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             25   ;                               -------
0000             26   ;
0000             27   
0000             28   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             29   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             30   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             31   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             32   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             33   
0000             34   ALARM_BUTTON  equ P0.4 
0000             35   UPDOWN        equ P1.1
0000             36   CLEAR_BUTTON  equ P1.5
0000             37   SOUND_OUT     equ P1.7
0000             38   AMPM_BUTTON   equ P1.2
0000             39   ;555_rst           equ P1.0
0000             40   
0000             41   ; Reset vector
0000             42   org 0x0000
0000 0201EC      43       ljmp main
0003             44       
0003             45   ; External interrupt 0
0003             46   org 0x0003
0003 0201BA      47       ljmp HOURS_ISR
0006             48   
0006             49   ; Timer0 overflow interrupt vector
000B             50   org 0x000B
000B 020137      51       ljmp Timer0_ISR
000E             52   
000E             53   ; Timer2 overflow interrupt vector
002B             54   org 0x002B
002B 020161      55       ljmp Timer2_ISR
002E             56   
003B             57   org 0x003B
003B 020414      58       ljmp PINS_ISR
003E             59   
003E             60   ;------------------------DATA SEGMENT----------------------------------------------------------;
003E             61   
003E             62   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             63   dseg at 0x30        ; datasegment
0030             64   Count1ms:      ds 2 ; 16-bit counter for the 1ms ticks
0032             65   seconds:       ds 1 ; Current BCD seconds
0033             66   minutes:       ds 1 ; Current BCD minutes
0034             67   hours:         ds 1 ; Current BCD hours
0035             68   alarm_minutes: ds 1 ; Alarm BCD minutes
0036             69   alarm_hours:   ds 1 ; Alarm BCD hours
0037             70   
0037             71   
0037             72   ;-----------------------BINARY SEGMENT---------------------------------------------------------;
0000             73   bseg
0000             74   seconds_flag: dbit 1 ; UPDATED FROM EXAMPLE: Set to one in the ISR every time 1000 ms had passed
0001             75   alarm_toggle: dbit 1 ; turn on/off alarm -- initialize it to 0 in main
0002             76   alarm_AMPM_toggle: dbit 1 ; 0 = AM, 1 = PM
0003             77   clock_AMPM_toggle: dbit 1 ; 0 = AM, 1 = PM
0004             78   
0004             79   
0004             80   ;-----------------------CODE SEGMENT----------------------------------------------------------;
003E             81   cseg                                                                                           
003E             82   ; These 'equ' must match the hardware wiring                                    
003E             83   LCD_RS equ P1.3
003E             84   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
003E             85   LCD_E  equ P1.4
003E             86   LCD_D4 equ P0.0
003E             87   LCD_D5 equ P0.1
003E             88   LCD_D6 equ P0.2
003E             89   LCD_D7 equ P0.3
003E             90   
                 92   	$LIST
00F2             94   
00F2             95   ;                     1234567890123456    <- This helps determine the location of the counter
00F2 54696D65    96   Initial_time:  db 'Time  12:00:00', 0
     20203132
     3A30303A
     303000
0101 416C6172    97   Alarm_time:    db 'Alarm 12:00', 0
     6D203132
     3A303000
010D 204F4E00    98   alarm_on:      db ' ON', 0
0111 4F464600    99   alarm_off:     db 'OFF', 0
0115 414D00     100   clock_AM:      db 'AM',0
0118 504D00     101   clock_PM:      db 'PM',0
011B 414D00     102   alarm_AM:      db 'AM', 0
011E 504D00     103   alarm_PM:      db 'PM', 0
0121            104   
0121            105   ;---------------------------------;
0121            106   ; Routine to initialize the ISR   ;
0121            107   ; for timer 0                     ;
0121            108   ;---------------------------------;
0121            109   Timer0_Init:
0121 438E08     110       orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
0124 E589       111       mov a, TMOD
0126 54F0       112       anl a, #0xf0 ; 11110000 Clear the bits for timer 0
0128 4401       113       orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
012A F589       114       mov TMOD, a
012C 758CF0     115       mov TH0, #high(TIMER0_RELOAD)
012F 758A2C     116       mov TL0, #low(TIMER0_RELOAD)
0132            117       ; Enable the timer and interrupts
0132 D2A9       118       setb ET0  ; Enable timer 0 interrupt
0134 D28C       119       setb TR0  ; Start timer 0
0136 22         120       ret
0137            121   
0137            122   ;---------------------------------;
0137            123   ; ISR for timer 0.  Set to execute;
0137            124   ; every 1/4096Hz to generate a    ;
0137            125   ; 2048 Hz wave at pin SOUND_OUT   ;
0137            126   ;---------------------------------;
0137            127   Timer0_ISR:
0137            128       ;clr TF0  ; According to the data sheet this is done for us already.
0137            129       ; Timer 0 doesn't have 16-bit auto-reload, so
0137 C28C       130       clr TR0
0139 758CF0     131       mov TH0, #high(TIMER0_RELOAD)
013C 758A2C     132       mov TL0, #low(TIMER0_RELOAD)
013F D28C       133       setb TR0
0141 B297       134       cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0143 32         135       reti
0144            136   
0144            137   ;---------------------------------;
0144            138   ; Routine to initialize the ISR   ;
0144            139   ; for timer 2                     ;
0144            140   ;---------------------------------;
0144            141   Timer2_Init:
0144 75C800     142       mov     T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0147 75CDBF     143       mov     TH2, #high(TIMER2_RELOAD)
014A 75CC28     144       mov     TL2, #low(TIMER2_RELOAD)
014D            145       ; Set the reload value
014D 43C980     146       orl     T2MOD, #0x80 ; Enable timer 2 autoreload
0150 75CBBF     147       mov     RCMP2H, #high(TIMER2_RELOAD)
0153 75CA28     148       mov     RCMP2L, #low(TIMER2_RELOAD)
0156            149       ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0156 E4         150       clr     a
0157 F530       151       mov     Count1ms+0, a
0159 F531       152       mov     Count1ms+1, a
015B            153       ; Enable the timer and interrupts
015B 439B82     154       orl     EIE, #0b10000010B ; Enable timer 2 interrupt ET2=1 AND enable pin interrupt: EPI = 1
015E            155   
015E D2CA       156       setb    TR2  ; Enable timer 2
0160 22         157       ret
0161            158   
0161            159   ; ----------------------------------------TIMER 2 ISR---------------------------------------;
0161            160   Timer2_ISR:
0161 C2CF       161       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0163            162       
0163            163       ; The two registers used in the ISR must be saved in the stack
0163 C0E0       164       push acc
0165 C0D0       165       push psw
0167            166       
0167            167       ; Increment the 16-bit one mili second counter
0167 0530       168       inc Count1ms+0    ; Increment the low 8-bits first
0169 E530       169       mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
016B 7002       170       jnz Inc_Done
016D 0531       171       inc Count1ms+1
016F            172   
016F            173   Inc_Done:
016F            174       ; Check if half second has passed
016F E530       175       mov a, Count1ms+0
0171 B4E841     176       cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0174 E531       177       mov a, Count1ms+1
0176 B4033C     178       cjne a, #high(1000), Timer2_ISR_done
0179            179       
0179            180       ; 1000 milliseconds have passed.  Set a flag so the main program knows
0179 D200       181       setb seconds_flag ; Let the main program know half second had passed
017B B28C       182       cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
017D            183       ; Reset to zero the milli-seconds counter, it is a 16-bit variable
017D E4         184       clr a
017E F530       185       mov Count1ms+0, a
0180 F531       186       mov Count1ms+1, a
0182            187       ; Increment the BCD counter
0182 E532       188       mov a, seconds
0184 309104     189       jnb UPDOWN, Timer2_ISR_decrement
0187 2401       190       add a, #0x01
0189 8002       191       sjmp Timer2_ISR_da
018B            192   Timer2_ISR_decrement:
018B 2499       193       add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
018D            194   Timer2_ISR_da:
018D D4         195       da a ; Decimal adjust instruction.  Check datasheet for more details!
018E F532       196       mov seconds, a
0190            197       
0190 B46022     198       cjne a, #0x60, seconds_done ; Fixed: Clock resets at 60
0193            199       
0193 753200     200       mov seconds, #0x00  ;
0196            201       
0196            202       ; Manual Increment of Minutes
0196 E533       203       mov a, minutes
0198 2401       204       add a, #0x01
019A D4         205       da  a
019B F533       206       mov minutes, a
019D B46015     207       cjne a, #0x60, seconds_done
01A0 753300     208       mov minutes, #0x00
01A3            209       
01A3            210       ; Manual Increment of Hours with AM/PM Logic
01A3 E534       211       mov a, hours
01A5 2401       212       add a, #0x01
01A7 D4         213       da  a
01A8 F534       214       mov hours, a
01AA            215       
01AA            216       ; Flip AM/PM when moving 11 -> 12
01AA B41202     217       cjne a, #0x12, check_13_auto
01AD B203       218       cpl clock_AMPM_toggle
01AF            219       
01AF            220   check_13_auto:
01AF B41303     221       cjne a, #0x13, seconds_done
01B2 753401     222       mov hours, #0x01
01B5            223       
01B5            224   seconds_done:
01B5            225       
01B5            226   Timer2_ISR_done:
01B5 D0D0       227       pop psw
01B7 D0E0       228       pop acc
01B9 32         229       reti
01BA            230   
01BA            231   
01BA            232   ;-----------------------HOURS BUTTON ISR-----------------------;
01BA            233   HOURS_ISR:
01BA C0E0       234       push    ACC
01BC C0D0       235       push    psw
01BE            236   
01BE            237       ; check if we're modifying alarm_hours or not 
01BE 200114     238       jb      alarm_toggle, alarm_hours_routine ; if alarm_toggle = 1, go do the alarm hours routine
01C1            239       ; this ISR will set the hours
01C1 E534       240       mov     a, hours
01C3 2401       241       add     a, #0x01
01C5 D4         242       da      a
01C6 F534       243       mov     hours, a
01C8            244       
01C8 B41202     245       cjne    a, #0x12, clock_13_man ; Check for AM/PM flip at 12
01CB B203       246       cpl     clock_AMPM_toggle
01CD            247   
01CD            248   clock_13_man:
01CD B41317     249       cjne    a, #0x13, HOURS_ISR_done ; if hours == 13, we've rolled over so reset to 1
01D0 753401     250       mov     hours, #0x01
01D3 8012       251       sjmp    HOURS_ISR_done
01D5            252   
01D5            253   alarm_hours_routine:
01D5 E536       254       mov     a, alarm_hours
01D7 2401       255       add     a, #0x01
01D9 D4         256       da      a
01DA F536       257       mov     alarm_hours, a
01DC            258   
01DC B41202     259       cjne    a, #0x12, alarm_13_man ; Check for AM/PM flip at 12
01DF B202       260       cpl     alarm_AMPM_toggle
01E1            261   
01E1            262   alarm_13_man:
01E1 B41303     263       cjne    a, #0x13, HOURS_ISR_done
01E4 753601     264       mov     alarm_hours, #0x01
01E7            265   
01E7            266   HOURS_ISR_done:
01E7 D0D0       267       pop psw
01E9 D0E0       268       pop ACC
01EB 32         269       reti
01EC            270   
01EC            271   
01EC            272   
01EC            273   ;---------------------------------;
01EC            274   ; Main program. Includes hardware ;
01EC            275   ; initialization and 'forever'    ;
01EC            276   ; loop.                           ;
01EC            277   ;---------------------------------;
01EC            278   main:
01EC 75817F     279       mov         SP  , #0x7F
01EF 75B100     280       mov         P0M1, #0x00
01F2 75B200     281       mov         P0M2, #0x00
01F5 75B300     282       mov         P1M1, #0x00
01F8 75B400     283       mov         P1M2, #0x00
01FB 75AD00     284       mov         P3M2, #0x00
01FE 75AC00     285       mov         P3M1, #0x00
0201 53B37E     286            anl         P1M1, #01111110B 
0204 43B481     287       orl         P1M2, #10000001B
0207            288   
0207            289   
0207            290             
0207 120121     291       lcall Timer0_Init
020A 120144     292       lcall Timer2_Init
020D            293   
020D            294       ;initailize the time to 12:00:00 PM
020D 753200     295       mov         seconds         , #0x00
0210 753300     296       mov         minutes         , #0x00
0213 753412     297       mov         hours           , #0x12
0216 753500     298       mov         alarm_minutes   , #0x00
0219 753612     299       mov         alarm_hours     , #0x12
021C C201       300       clr         alarm_toggle    ; Initialize edit mode bit to zero
021E C202       301       clr         alarm_AMPM_toggle ; 0 = AM
0220 C203       302       clr         clock_AMPM_toggle ; 0 = AM
0222            303      ; setb                        555_rst                         ;, #0x00 ; extra feature!!!!!!!
0222 D290       304      setb                  P1.0
0224            305   
0224 D2AF       306       setb EA   
0226            307   
0226            308   ;----------------INITIALIZE EXTERNAL INTERRUPT 0-----------------;
0226 D2A8       309       setb EX0
0228 D288       310       setb IT0
022A            311   ;----------------INITIALIZE PIN INTERRUPTS--------------;
022A            312   
022A            313       ; pins .1, 2, 6
022A 75E999     314       mov     PICON, #10011001B
022D 75EA46     315       mov     PINEN, #01000110B
0230            316   
0230 439B02     317       orl     EIE, #00000010B
0233            318   
0233            319   
0233            320   
0233 120097     321       lcall LCD_4BIT
0236 740C       322            mov a, #0x0C
0238 120092     322            lcall ?WriteCommand
023B            323   
023B C0E0       324            push acc
023D 7401       324            mov a, #1
023F 14         324            dec a
0240 1200D7     324            lcall ?Set_Cursor_1 ; Select column and row
0243 D0E0       324            pop acc
0245 C083       325            push dph
0247 C082       325            push dpl
0249 C0E0       325            push acc
024B 9000F2     325            mov dptr, #Initial_time
024E 1200CA     325            lcall ?Send_Constant_String
0251 D0E0       325            pop acc
0253 D082       325            pop dpl
0255 D083       325            pop dph
0257            326   
0257 C0E0       327            push acc
0259 7401       327            mov a, #1
025B 14         327            dec a
025C 1200D5     327            lcall ?Set_Cursor_2 ; Select column and row
025F D0E0       327            pop acc
0261 C083       328            push dph
0263 C082       328            push dpl
0265 C0E0       328            push acc
0267 900101     328            mov dptr, #Alarm_time
026A 1200CA     328            lcall ?Send_Constant_String
026D D0E0       328            pop acc
026F D082       328            pop dpl
0271 D083       328            pop dph
0273 C0E0       329            push acc
0275 740E       329            mov a, #14
0277 14         329            dec a
0278 1200D5     329            lcall ?Set_Cursor_2 ; Select column and row
027B D0E0       329            pop acc
027D C083       330            push dph
027F C082       330            push dpl
0281 C0E0       330            push acc
0283 900111     330            mov dptr, #alarm_off
0286 1200CA     330            lcall ?Send_Constant_String
0289 D0E0       330            pop acc
028B D082       330            pop dpl
028D D083       330            pop dph ; Initial status
028F            331   
028F D200       332       setb seconds_flag
0291 753200     333       mov seconds, #0x00
0294            334       
0294            335   
0294            336   loop:
0294            337   
0294            338   
0294            339   ;-------------------------------ALARM TOGGLE CHECK (polling)----------------------------------;
0294            340   alarm_check_routine:
0294            341       ; toggle the edit mode bit. 
0294            342   
0294 20844E     343       jb      ALARM_BUTTON, AMPM_check_routine 
0297 C002       344            push AR2
0299 7A32       344            mov R2, #50
029B 120048     344            lcall ?Wait_Milli_Seconds
029E D002       344            pop AR2
02A0 208442     345       jb      ALARM_BUTTON, AMPM_check_routine
02A3 3084FD     346       jnb     ALARM_BUTTON, $ ; wait for release
02A6            347   
02A6 B201       348       cpl     alarm_toggle ; compliment the variable
02A8            349       
02A8 20011E     350       jb      alarm_toggle, show_alarm_on
02AB C0E0       351            push acc
02AD 740E       351            mov a, #14
02AF 14         351            dec a
02B0 1200D5     351            lcall ?Set_Cursor_2 ; Select column and row
02B3 D0E0       351            pop acc
02B5 C083       352            push dph
02B7 C082       352            push dpl
02B9 C0E0       352            push acc
02BB 900111     352            mov dptr, #alarm_off
02BE 1200CA     352            lcall ?Send_Constant_String
02C1 D0E0       352            pop acc
02C3 D082       352            pop dpl
02C5 D083       352            pop dph
02C7 801C       353       sjmp    AMPM_check_routine
02C9            354   
02C9            355   show_alarm_on:
02C9 C0E0       356            push acc
02CB 740E       356            mov a, #14
02CD 14         356            dec a
02CE 1200D5     356            lcall ?Set_Cursor_2 ; Select column and row
02D1 D0E0       356            pop acc
02D3 C083       357            push dph
02D5 C082       357            push dpl
02D7 C0E0       357            push acc
02D9 90010D     357            mov dptr, #alarm_on
02DC 1200CA     357            lcall ?Send_Constant_String
02DF D0E0       357            pop acc
02E1 D082       357            pop dpl
02E3 D083       357            pop dph
02E5            358   
02E5            359   
02E5            360   ;-------------------------------AMPM TOGGLE CHECK (polling)------------------------;
02E5            361   
02E5            362   AMPM_check_routine:
02E5 209218     363       jb      AMPM_BUTTON, check_clear 
02E8 C002       364            push AR2
02EA 7A32       364            mov R2, #50
02EC 120048     364            lcall ?Wait_Milli_Seconds
02EF D002       364            pop AR2
02F1 20920C     365       jb      AMPM_BUTTON, check_clear
02F4 3092FD     366       jnb     AMPM_BUTTON, $ ; wait for release
02F7            367   
02F7 200104     368       jb      alarm_toggle, toggle_alarm_ampm_man
02FA B203       369       cpl     clock_AMPM_toggle
02FC 8002       370       sjmp    check_clear
02FE            371   
02FE            372   toggle_alarm_ampm_man:
02FE B202       373       cpl     alarm_AMPM_toggle
0300            374   
0300            375   
0300            376   ;--------------------------------CLEAR BUTTON CHECK (polling)-----------------------------------------------;
0300            377   
0300            378   check_clear:
0300            379   
0300 20951C     380       jb           CLEAR_BUTTON, loop_a  ; if (CLEAR_BUTTON) skip
0303 C002       381            push AR2
0305 7A32       381            mov R2, #50
0307 120048     381            lcall ?Wait_Milli_Seconds
030A D002       381            pop AR2 ; Debounce delay.  
030C 209510     382       jb           CLEAR_BUTTON, loop_a  ; another check
030F 3095FD     383       jnb          CLEAR_BUTTON, $     ; Wait for button release.  
0312            384       ; A valid press of the 'CLEAR' button has been detected, reset the BCD counter.
0312 C2CA       385       clr          TR2                 ; Stop timer 2
0314 E4         386       clr          a
0315 F530       387       mov          Count1ms+0, a
0317 F531       388       mov          Count1ms+1, a
0319            389       ; Now clear the BCD counter
0319 F532       390       mov          seconds, a
031B D2CA       391       setb         TR2                ; Start timer 2
031D 8006       392       sjmp         loop_b              ; Display the new value
031F            393   loop_a:
031F 200003     394       jb           seconds_flag, loop_b  ; If flag is set, jump over the long jump to the display code
0322 020294     395       ljmp         loop                ; Otherwise, use a Long Jump to reach the distant top
0325            396   loop_b:
0325            397   
0325 C200       398       clr          seconds_flag     ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0327            399   
0327 C0E0       400            push acc
0329 7407       400            mov a, #7
032B 14         400            dec a
032C 1200D7     400            lcall ?Set_Cursor_1 ; Select column and row
032F D0E0       400            pop acc
0331 C000       401            push ar0
0333 A834       401            mov r0, hours
0335 1200DC     401            lcall ?Display_BCD
0338 D000       401            pop ar0
033A            402   
033A C0E0       403            push acc
033C 740A       403            mov a, #10
033E 14         403            dec a
033F 1200D7     403            lcall ?Set_Cursor_1 ; Select column and row
0342 D0E0       403            pop acc
0344 C000       404            push ar0
0346 A833       404            mov r0, minutes
0348 1200DC     404            lcall ?Display_BCD
034B D000       404            pop ar0
034D            405   
034D C0E0       406            push acc
034F 740D       406            mov a, #13
0351 14         406            dec a
0352 1200D7     406            lcall ?Set_Cursor_1 ; Select column and row
0355 D0E0       406            pop acc    
0357 C000       407            push ar0
0359 A832       407            mov r0, seconds
035B 1200DC     407            lcall ?Display_BCD
035E D000       407            pop ar0 
0360            408   
0360 C0E0       409            push acc
0362 740F       409            mov a, #15
0364 14         409            dec a
0365 1200D7     409            lcall ?Set_Cursor_1 ; Select column and row
0368 D0E0       409            pop acc
036A 200314     410       jb clock_AMPM_toggle, show_clock_pm_str
036D C083       411            push dph
036F C082       411            push dpl
0371 C0E0       411            push acc
0373 900115     411            mov dptr, #clock_AM
0376 1200CA     411            lcall ?Send_Constant_String
0379 D0E0       411            pop acc
037B D082       411            pop dpl
037D D083       411            pop dph
037F 8012       412       sjmp display_alarm_data
0381            413   
0381            414   show_clock_pm_str:
0381 C083       415            push dph
0383 C082       415            push dpl
0385 C0E0       415            push acc
0387 900118     415            mov dptr, #clock_PM
038A 1200CA     415            lcall ?Send_Constant_String
038D D0E0       415            pop acc
038F D082       415            pop dpl
0391 D083       415            pop dph
0393            416   
0393            417   display_alarm_data:
0393 C0E0       418            push acc
0395 7407       418            mov a, #7
0397 14         418            dec a
0398 1200D5     418            lcall ?Set_Cursor_2 ; Select column and row
039B D0E0       418            pop acc
039D C000       419            push ar0
039F A836       419            mov r0, alarm_hours
03A1 1200DC     419            lcall ?Display_BCD
03A4 D000       419            pop ar0
03A6            420   
03A6 C0E0       421            push acc
03A8 740A       421            mov a, #10
03AA 14         421            dec a
03AB 1200D5     421            lcall ?Set_Cursor_2 ; Select column and row
03AE D0E0       421            pop acc
03B0 C000       422            push ar0
03B2 A835       422            mov r0, alarm_minutes
03B4 1200DC     422            lcall ?Display_BCD
03B7 D000       422            pop ar0
03B9            423   
03B9 C0E0       424            push acc
03BB 740C       424            mov a, #12
03BD 14         424            dec a
03BE 1200D5     424            lcall ?Set_Cursor_2 ; Select column and row
03C1 D0E0       424            pop acc
03C3 200214     425       jb alarm_AMPM_toggle, show_alarm_pm_str
03C6 C083       426            push dph
03C8 C082       426            push dpl
03CA C0E0       426            push acc
03CC 90011B     426            mov dptr, #alarm_AM
03CF 1200CA     426            lcall ?Send_Constant_String
03D2 D0E0       426            pop acc
03D4 D082       426            pop dpl
03D6 D083       426            pop dph
03D8 8012       427       sjmp alarm_compare_logic_label
03DA            428   show_alarm_pm_str:
03DA C083       429            push dph
03DC C082       429            push dpl
03DE C0E0       429            push acc
03E0 90011E     429            mov dptr, #alarm_PM
03E3 1200CA     429            lcall ?Send_Constant_String
03E6 D0E0       429            pop acc
03E8 D082       429            pop dpl
03EA D083       429            pop dph
03EC            430   
03EC            431   ;-----------------------ALARM COMPARISON-----------------------------------;
03EC            432   alarm_compare_logic_label:
03EC            433       ; 1. Check if hours match
03EC E534       434       mov         a, hours
03EE B5361A     435       cjne        a, alarm_hours, alarm_beep_stop 
03F1            436       
03F1            437       ; 2. Check if minutes match
03F1 E533       438       mov         a, minutes
03F3 B53515     439       cjne        a, alarm_minutes, alarm_beep_stop 
03F6            440   
03F6            441       ; 3. Check AM/PM match
03F6 200305     442       jb          clock_AMPM_toggle, check_pm_match
03F9 20020F     443       jb          alarm_AMPM_toggle, alarm_beep_stop  
03FC 8003       444       sjmp        check_alarm_enabled                    
03FE            445   
03FE            446   check_pm_match:
03FE 30020A     447       jnb         alarm_AMPM_toggle, alarm_beep_stop  
0401            448   
0401            449   check_alarm_enabled:
0401            450       ; --- NEW GATEKEEPER CHECK ---
0401            451       ; If alarm_toggle is 0 (OFF), we jump to stop beeping immediately
0401            452       ; even though the hours/minutes/AMPM match perfectly.
0401 300107     453       jnb         alarm_toggle, alarm_beep_stop
0404            454   
0404            455   start_the_beep:
0404 D2A9       456       setb        ET0 ; Enable sound interrupt
0406 D290       457       setb        P1.0 ; Enable LED Blinker
0408 020294     458       ljmp        loop
040B            459   
040B            460   alarm_beep_stop:  
040B C2A9       461       clr         ET0 ; Disable sound interrupt 
040D C297       462       clr         SOUND_OUT ; Force speaker pin low to stop buzz
040F C290       463       clr         P1.0 ; Turn off LED Blinker
0411 020294     464       ljmp        loop
0414            465           
0414            466   ;----------------------PINS (1.1, 1.2, and 1.6) GENERAL INTERRUPT ISR---------------;
0414            467   ; all pin interrupts will jump here and so then we'll use a controller to poll which pin it was using PIF register
0414            468   
0414            469   PINS_ISR:
0414 C0E0       470       push    ACC
0416 C0D0       471       push    psw
0418            472   
0418 E5EC       473       mov     a, PIF     ; copy the flags into a
041A 75EC00     474       mov     PIF, #0x00 ; clear flags via software as stated in DS
041D            475       
041D            476       ; checking for PIF6, P1.6, which is pin 8, for the minutes 
041D F5F0       477       mov     b, a ; Keep a copy for ELIF_seconds
041F 5440       478       anl     a, #01000000B
0421 6021       479       jz      ELIF_seconds ; if PIF6 is 0, skip to seconds check
0423            480   
0423            481   ; fall through if equal
0423            482   IF_minutes:
0423            483       ; if alarm mode bit = 1, then we want to change the alarm
0423 20010F     484       jb      alarm_toggle, IF_alarm_minutes
0426            485   
0426 E533       486       mov     a, minutes 
0428 2401       487       add     a, #0x01
042A D4         488       da      a
042B F533       489       mov     minutes, a
042D            490   
042D            491       ; overflow check
042D B46003     492       cjne    a, #0x60, minutes_done ; if minutes == 60, we've rolled over so reset to 0
0430 753300     493       mov     minutes, #0x00
0433            494   
0433            495   minutes_done:
0433 8022       496       sjmp    PINS_ISR_DONE
0435            497   
0435            498   IF_alarm_minutes:
0435            499       ; first increment the minutes and check for rollover
0435 E535       500       mov     a, alarm_minutes
0437 2401       501       add     a, #0x01    
0439 D4         502       da      a
043A F535       503       mov     alarm_minutes, a
043C            504   
043C B46003     505       cjne    a, #0x60, alarm_minutes_done
043F 753500     506       mov     alarm_minutes, #0x0
0442            507   
0442            508   alarm_minutes_done:
0442 8013       509       sjmp    PINS_ISR_DONE
0444            510   
0444            511   
0444            512   ELIF_seconds: ; poll pin 15 (seconds adjust button)
0444 E5F0       513       mov     a, b
0446 5402       514       anl     a, #00000010B ; Check Bit 1 (P1.1)
0448 600D       515       jz      PINS_ISR_DONE
044A            516   
044A E532       517       mov     a, seconds
044C 2401       518       add     a, #0x01        ; add 1 to the seconds counter
044E D4         519       da      a               ; decima adjust
044F F532       520       mov     seconds, a      ; put the updated value back into seconds variable 
0451            521   
0451 B46003     522       cjne    a, #0x60, PINS_ISR_DONE ; Check rollover at 60
0454 753200     523       mov     seconds, #0x00
0457            524       
0457            525   PINS_ISR_DONE:
0457 D0D0       526       pop          psw
0459 D0E0       527       pop          ACC
045B 32         528       reti
045C            529   
045C            530   EN
